<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://phantom23333.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://phantom23333.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-08T16:20:48+00:00</updated><id>https://phantom23333.github.io/feed.xml</id><title type="html">blank</title><subtitle>Portfolio website </subtitle><entry><title type="html">Notes CUDA</title><link href="https://phantom23333.github.io/blog/2022/Notes-CUDA/" rel="alternate" type="text/html" title="Notes CUDA"/><published>2022-12-11T00:00:00+00:00</published><updated>2022-12-11T00:00:00+00:00</updated><id>https://phantom23333.github.io/blog/2022/Notes-CUDA</id><content type="html" xml:base="https://phantom23333.github.io/blog/2022/Notes-CUDA/"><![CDATA[<p>Notes for CUDA</p> <ol> <li>Setting grid and block dimensions <ul> <li>Un-initialized dimension (.x, .y, .z) is set to 1 by default. <pre><code class="language-C++"> dim3 grid (1024, 8);
 dim3 block (512, 1);
 myKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_data);
</code></pre> </li> </ul> </li> <li>Don’t do this: <pre><code class="language-C++"> dim3 grid = (1024, 8); // !!!! Wrongly initialised values!!!!
</code></pre> </li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[self-notes]]></summary></entry><entry><title type="html">Notes C++</title><link href="https://phantom23333.github.io/blog/2022/Notes-Cpp/" rel="alternate" type="text/html" title="Notes C++"/><published>2022-07-17T00:00:00+00:00</published><updated>2022-07-17T00:00:00+00:00</updated><id>https://phantom23333.github.io/blog/2022/Notes-Cpp</id><content type="html" xml:base="https://phantom23333.github.io/blog/2022/Notes-Cpp/"><![CDATA[<p>Notes for C++</p> <ol> <li><code class="language-plaintext highlighter-rouge">push_back()</code> vs <code class="language-plaintext highlighter-rouge">emplace_back()</code> <ul> <li>copy vs move</li> <li>vec.insert({a, b}) vs vec.emplace(a, b)</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">const</code> vs <code class="language-plaintext highlighter-rouge">constexpr</code> <ul> <li><code class="language-plaintext highlighter-rouge">const</code> : could be compile-time or runtime constants</li> <li><code class="language-plaintext highlighter-rouge">constexpr</code> : enforces compile-time constants. Fxns might still be runtime, check next point.</li> <li>Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as <code class="language-plaintext highlighter-rouge">constexpr</code>.</li> <li>Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as <code class="language-plaintext highlighter-rouge">const</code>.</li> <li><a href="learncpp.com">https://www.learncpp.com/cpp-tutorial/compile-time-constants-constant-expressions-and-constexpr/</a></li> <li>Don’t use <code class="language-plaintext highlighter-rouge">const</code> when passing by value.</li> <li>Don’t use <code class="language-plaintext highlighter-rouge">const</code> when returning by value.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">constexpr</code> and <code class="language-plaintext highlighter-rouge">consteval</code>. <a href="https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/">Link</a> <ul> <li><code class="language-plaintext highlighter-rouge">constexpr</code> <ul> <li>can be called by both compile-time and runtime functions.</li> <li>to ensure compile-time, capture the return value in a new constexpr variable.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">consteval</code> : <strong>– C++20 –</strong> <ul> <li>cannot be called during runtime</li> <li>enforces compile-time call. Parameters should be constexpr.</li> </ul> </li> </ul> </li> <li>Lambda <ul> <li></li> </ul> </li> <li>Variable initialisation. <ul> <li>3 ways: <ul> <li><strong>Copy</strong> (<code class="language-plaintext highlighter-rouge">=</code>) : Copy values.</li> <li><strong>Direct</strong> (<code class="language-plaintext highlighter-rouge">()</code>) : Direct initializer.</li> <li><strong>Brace</strong> (<code class="language-plaintext highlighter-rouge">{}</code>) : Direct list initializer. <code class="language-plaintext highlighter-rouge">&lt;--- use this</code></li> </ul> </li> <li>Default value for uninitialised variable:</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>    <span class="c1">// bad: undetermined. could be anything.</span>
 <span class="kt">int</span> <span class="nf">b</span><span class="p">();</span>  <span class="c1">// bad: interpreted as a function. Will return true!</span>
 <span class="kt">int</span> <span class="n">c</span><span class="p">{};</span>  <span class="c1">// good: init to 0</span>
 <span class="kt">int</span> <span class="n">d</span><span class="p">{</span><span class="mf">4.5</span><span class="p">};</span> <span class="c1">// [error][but safer]. {} doesn't allow value which d can't hold. Doesn't drop '.5' automatically like other 2 methods</span>
 <span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// empty string of size 0 i.e. s = ""</span>
</code></pre></div> </div> </li> <li>Postfix operator has higher precedence than prefix operator. <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="c1">// increment ptr but deref the un-incremented address</span>
</code></pre></div> </div> </li> <li>Operators which are mainly used for their ‘side effects’ return their <strong>left operand</strong>. This allows chaining. <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// evaluates as x = (y = 5)</span>
 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello "</span> <span class="o">&lt;&lt;</span> <span class="s">"world"</span><span class="p">;</span> <span class="c1">// evaluates as (std::cout &lt;&lt; "Hello ") &lt;&lt; "world!"</span>
</code></pre></div> </div> </li> <li>Macros are bad: <ul> <li>Can’t be treated as normal variables. So, hard time to debug with debuggers; would see the name &amp; not the actual value. Debuggers ‘watch’ these variables.</li> <li>Don’t follow normal scoping rules; might end up getting used somewhere in the code!</li> <li>Risk of a variable being defined as a macro in some file.</li> </ul> </li> <li>Vector <code class="language-plaintext highlighter-rouge">reserve()</code> vs <code class="language-plaintext highlighter-rouge">resize()</code> vs nothing!: <ul> <li><code class="language-plaintext highlighter-rouge">reserve</code> would allocate memory ahead of time. <strong>Capacity</strong> will be affected, not size.</li> <li><code class="language-plaintext highlighter-rouge">resize</code> would insert or delete elements. <strong>Size</strong> is affected. Capacity may not be if new size &lt;= old capacity.</li> <li>nothing would grow/double the vector when size&gt;capacity. Required O(N) copying everytime!!</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">lvalue</code> vs <code class="language-plaintext highlighter-rouge">rvalue</code>: <ul> <li><code class="language-plaintext highlighter-rouge">lvalues</code> : variables/objects that persist beyond the end of the expression.</li> <li><code class="language-plaintext highlighter-rouge">rvalues</code> : literals or returned value of functions/operators that are discarded at the end of expression.</li> </ul> </li> <li>pointers(*) vs reference(&amp;): <a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable?page=1&amp;tab=scoredesc#tab-top">Great answer link</a> <ul> <li>pointer: First account forwarding to second account. The pointer itself has a memory location. <ul> <li>name1@email.com -&gt; name_surname@email.com</li> </ul> </li> <li>reference: <strong>Alias</strong> of email. Both are same account; no separate memory. <ul> <li>netID@uni.com, first.last@uni.com</li> <li>has to be initialised. can’t be reseated.</li> </ul> </li> </ul> </li> <li>L-value reference with <code class="language-plaintext highlighter-rouge">const</code>: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="p">{</span> <span class="mi">50</span> <span class="p">};</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">{</span><span class="mi">100</span><span class="p">};</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="p">{</span> <span class="n">x</span> <span class="p">};</span>           <span class="c1">// valid: lvalue reference bound to a modifiable lvalue</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">const_ref</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span> <span class="c1">// still valid</span>

<span class="c1">// const_ref = 51 // invalid: can't change through const reference.</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span>           <span class="c1">// valid: can be changed through non-const identifier </span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&lt;&lt;</span> <span class="n">ref</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">const_ref</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 51 51</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_y</span> <span class="p">{</span> <span class="n">y</span> <span class="p">};</span>           <span class="c1">// invalid: can't bind to a non-modifiable lvalue</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_y_const</span> <span class="p">{</span><span class="n">y</span><span class="p">};</span> <span class="c1">// valid</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_rvalue</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>        <span class="c1">// invalid: can't bind to an r-value. Else you'll try to modify 1 using the reference</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_rvalue2</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// valid: temporary object of rvalue is created.</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">const</code> ptr : <a href="https://compiler-explorer.com/z/o716TG8oo">compiler-explorer link</a> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">const</span> <span class="n">MyClass</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
    <span class="n">MyClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">MyClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span> <span class="c1">//read-only</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">unique_ptr</code> and <code class="language-plaintext highlighter-rouge">shared_ptr</code>: <ul> <li>unique_ptr</li> <li>shared_ptr : multiple smart pointers share the same resource. Resource is deallocated when the last smart ptr goes out of scope (count==0) <ul> <li>uses reference counting for control block.</li> <li>prefer make_shared. Combines resource + control into a sigle memory.</li> </ul> </li> </ul> </li> <li>Caution: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">decimal</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">binary</span> <span class="o">=</span> <span class="mb">0b1010</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">hex</span> <span class="o">=</span> <span class="mh">0x1010</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">octal</span> <span class="o">=</span> <span class="mo">010</span><span class="p">;</span> <span class="c1">// &lt;-- prefix zero means Octal!!</span>
</code></pre></div> </div> </li> <li>Python-like bindings: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span><span class="o">:</span> <span class="n">my_map</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>Classes: <ul> <li><a href="https://compiler-explorer.com/z/oh434PqG9">Compiler Explorer code link</a></li> <li>Default access to members and methods is private</li> <li>classes with virtual functions maintain <em>vtbl (virtual function table)</em> to determine the function call</li> <li></li> </ul> </li> <li>Dynamic &amp; Static cast: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span><span class="p">(</span><span class="n">TypeA</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">TypeA</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">)){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ptr is of TypeA"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
</code></pre></div> </div> </li> <li>Move vs Copy - <a href="https://godbolt.org/z/jvn9dd4Mq">Compiler Explorer, Quick C++ Benchmark</a></li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[self-notes]]></summary></entry></feed>